<!DOCTYPE html>
<html>
<head>
	<script src="http://libs.baidu.com/jquery/2.0.0/jquery.js"></script>
</head>
<body>
	<div class="main">
		<canvas id="canvas" width="600" height="400"></canvas>
	</div>
	<script>
		var canvas = document.getElementById('canvas');
		var ctx = canvas.getContext('2d');
		
		ctx.fillStyle = ctx.stokeStyle = '#ccc';
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		var rect1 = {
			x : 300,
			y : 200,
			width : 100,
			height : 100,
			angle : 60
		};
		var rect2 = {
			x : 202,
			y : 90,
			width : 50,
			height : 120,
			angle : 0
		};

		function drawRect (obj) {
			var x = obj.x,
				y = obj.y,
				w = obj.width,
				h = obj.height,
				angle = Math.PI * (obj.angle / 180);

			ctx.save();
			ctx.beginPath();
			ctx.fillStyle = '#000';
			ctx.translate(x + w / 2, y + h / 2);
			ctx.rotate(angle);
			ctx.rect(-w / 2, -h / 2, w, h);
			ctx.translate(-x - w / 2, -y - h / 2);
			ctx.closePath();
			ctx.fill();
			ctx.restore();
		}
		ctx.save();
		drawRect(rect1);
		drawRect(rect2);
		var resTmp = rotateRectCollide(rect1, rect2);
		console.log(resTmp);
		ctx.restore();
		/*获取sacle之后的坐标位置*/
		// 二维变换 xPos, yPos为缩放的中心点
		function sacleMatrix(point, xSacle, yScale, xPos, yPos) {
			var m = [
						[0, 0, 0],
						[0, 0, 0],
						[0, 0, 1]
					 ];
			m[0][0] = xSacle;
			m[1][1] = yScale;
			m[2][0] = -(xSacle - 1) * xPos;
			m[2][1] = -(yScale - 1) * yPos;
			var result = Matrix(point, m);
			return result;
		};


		// 矩阵乘法
		function Matrix(arr, matrix) {
			var result = [];
			for (var i = 0, len = matrix.length; i < len; i++) {
				var sum = 0;
				for (var j = 0; j < matrix[i].length; j++) {
					sum += arr[j] * matrix[j][i];
				}
				result.push(sum);
			}
			
			return result;
		}
		
		function rotateRectCollide (obj1, obj2) {
			/*分别获取矩形左右两边和上下两边的轴向量*/
			console.dir(obj1);
			var obj1 = getVector(obj1)			
			var obj2 = getVector(obj2);
			
			var collide = true;

			console.dir(obj1);
			for (var i = 0; i < axis.length; i++) {
				var line = axis[i];
				var tmp2 = getMaxMin(line, obj2);
				var tmp1 = getMaxMin(line, obj1);
				// console.log(tmp1.max, tmp2.min, tmp1.max < tmp2.min );
				// console.log(tmp1.min, tmp2.max, tmp1.min >tmp2.max);
				if (tmp1.max < tmp2.min || tmp1.min >tmp2.max)  {
					console.log('no collide!');
					collide = false;
					return false;
				}
			}
			// console.log(tmp1.max, tmp1.min, tmp2.max, tmp2.min);
			// 更正坐标系
			console.log('collide');
			return collide;
		}

		/*返回矩形顶点在投影坐标上最大值和最小值*/
		function getMaxMin (vector, obj) {
			var arr = [];
			// console.log(vector.x, vector.y);
			arr.push(vectorToPoint(vector, obj.topLeftPoint));
			arr.push(vectorToPoint(vector, obj.topRightPoint));
			arr.push(vectorToPoint(vector, obj.bottomLeftPoint));
			arr.push(vectorToPoint(vector, obj.bottomRightPoint));

			arr = arr.sort(function (a, b) {
				return b - a;
			});

			// console.dir(arr);
			return {
				max : arr[0],
				min : arr[arr.length - 1]
			};
		}
		/*获取矩形的轴向量*/
		function getVector(obj) {
			/*依次获取四个顶点和中心点*/
			var topLeftPoint = {
					x : obj.x,
					y : obj.y
				},
				topRightPoint = {
					x : obj.x + obj.width,
					y : obj.y
				},
				bottomLeftPoint = {
					x : obj.x,
					y : obj.y + obj.height
				},
				bottomRightPoint = {
					x : obj.x + obj.width,
					y : obj.y + obj.height
				},
				centerPoint = {
					x : obj.x + obj.width >> 1,
					y : obj.y + obj.height >> 1
				},
				angle = obj.angle;

			/*旋转之后的三个顶点*/
			topLeftPoint = rotationMatrix(topLeftPoint, centerPoint, angle);
			topRightPoint = rotationMatrix(topRightPoint, centerPoint, angle);
			bottomLeftPoint = rotationMatrix(bottomLeftPoint, centerPoint, angle);
			bottomRightPoint = rotationMatrix(bottomRightPoint, centerPoint, angle);
			/*获取两条轴向量*/
			var horizontalAxis = {
				x : topLeftPoint.x - bottomLeftPoint.x,
				y : topLeftPoint.y - bottomLeftPoint.y
			};
			var verticalAxis = {
				x : topRightPoint.x - topLeftPoint.x,
				y : topRightPoint.y - topLeftPoint.y
			};
			var result = {
				horizontalAxis : horizontalAxis,
				verticalAxis : verticalAxis,
				topLeftPoint : topLeftPoint,
				topRightPoint : topRightPoint,
				bottomLeftPoint : bottomLeftPoint,
				bottomRightPoint : bottomRightPoint
			};
			return result;
		}

		/*获取旋转之后的坐标位置*/
		// centerPoin为围绕该点进行旋转
		function rotationMatrix(pointObj, centerPointObj, angle) {
			var m = [
						[0, 0, 0],
						[0, 0, 0],
						[0, 0, 1]
					 ];
			var cos = Math.cos,
				sin = Math.sin,
				angle = angle / 180 * Math.PI;

			m[0][0] = cos(angle);
			m[0][1] = sin(angle);
			m[1][0] = -sin(angle);
			m[1][1] = cos(angle);

			var point = [pointObj.x, pointObj.y, 1];
			var centerPoint = [centerPointObj.x, centerPointObj.y, 1];
			var relativePoint = [], result = [];

			for (var i = 0; i < point.length; i++) {
				relativePoint.push(point[i] - centerPoint[i]);
			}
			var tmp = Matrix(relativePoint, m);
			for (var i = 0; i < point.length; i++) {
				result.push(tmp[i] + centerPoint[i]);
			}
			return {
				x : result[0],
				y : result[1]
			};
		}

		/*获得该点在在向量上的投影点坐标*/
		function vectorToPoint (vector, point) {

			var slope = (point.x * vector.x + point.y * vector.y) / (vector.x * vector.x + vector.y * vector.y);

			// 获取对应的投影点
			var pointTmp =  {
				x : slope * vector.x,
				y : slope * vector.y
			};
			// console.log(vector.x, vector.y, pointTmp.x, pointTmp.y);
			// console.dir(pointTmp);
			// 返回标量值
			return slope;
		}
	</script>
</body>
</html>